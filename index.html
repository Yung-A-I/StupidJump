<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Doodle Jump Clone - Mobile & Shooting</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Gochi+Hand&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            font-family: 'Gochi Hand', 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            background-color: #fcfcf7;
            display: block;
            border: 2px solid #333;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.95);
            text-align: center;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 48px;
            color: #d3ad28;
            text-shadow: 3px 3px 0px #333;
            margin: 0 0 10px 0;
            line-height: 1;
        }

        p {
            font-size: 20px;
            color: #333;
            margin: 5px 0;
            font-weight: bold;
        }

        .btn {
            margin-top: 10px;
            padding: 10px 30px;
            font-size: 24px;
            font-family: inherit;
            background-color: #6b8c42;
            color: white;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .btn:hover {
            transform: scale(1.05);
            background-color: #7da34d;
        }
        
        .btn-small {
            margin-top: 10px;
            padding: 5px 15px;
            font-size: 18px;
            background-color: #4a90e2;
            color: white;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
        }

        .score-box {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            background: rgba(255,255,255,0.6);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* Shop Styles */
        #shop-screen {
            background: #fff;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            justify-content: flex-start;
        }
        .shop-section {
            width: 100%;
            margin-bottom: 20px;
        }
        .shop-title {
            font-size: 28px;
            color: #333;
            border-bottom: 2px solid #eee;
            margin-bottom: 10px;
            width: 100%;
        }
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
        }
        .shop-item {
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #fafafa;
        }
        .shop-item.selected {
            border-color: #6b8c42;
            background: #e8f5e9;
        }
        .shop-item.locked {
            opacity: 0.7;
        }
        .item-name { font-size: 18px; font-weight: bold; }
        .item-cost { font-size: 14px; color: #d32f2f; }
        .currency-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #fff;
            padding: 5px 10px;
            border: 2px solid #333;
            border-radius: 5px;
            font-weight: bold;
            color: #d3ad28;
        }
        .back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="hud" class="hidden">
            <div class="score-box" id="score-display">0</div>
            <div class="score-box" id="highscore-display">Top: 0</div>
        </div>

        <div id="start-screen" class="overlay">
            <h1>DOODLE<br>JUMP</h1>
            <p>Tilt or <span style="color:#6b8c42">← →</span> to Move</p>
            <p>Tap or <span style="color:#6b8c42">Space</span> to Shoot</p>
            <p style="font-size: 16px; margin-top:15px; color: #555;">Boost off the Green Bot • Shoot other Enemies</p>
            <button class="btn" id="start-btn">Play</button>
            <button class="btn-small" id="shop-btn">Shop / Skins</button>
        </div>

        <div id="shop-screen" class="overlay hidden">
            <button class="btn-small back-btn" id="close-shop-btn">← Back</button>
            <div class="currency-display">Coins: <span id="shop-currency">0</span></div>
            
            <div style="height: 40px;"></div> <!-- Spacer -->
            
            <div class="shop-section">
                <div class="shop-title">Characters</div>
                <div class="shop-grid" id="char-grid">
                    <!-- Generated via JS -->
                </div>
            </div>

            <div class="shop-section">
                <div class="shop-title">Backgrounds</div>
                <div class="shop-grid" id="bg-grid">
                    <!-- Generated via JS -->
                </div>
            </div>
        </div>

        <div id="game-over-screen" class="overlay hidden">
            <h1 style="color: #cf3e3e">GAME OVER</h1>
            <p>Score: <span id="final-score">0</span></p>
            <p>Best: <span id="final-high">0</span></p>
            <p style="font-size: 16px; color: #666;">Total Coins: <span id="total-coins-display">0</span></p>
            <button class="btn" id="restart-btn">Play Again</button>
            <button class="btn-small" id="shop-btn-over">Shop</button>
        </div>

        <canvas id="gameCanvas" width="400" height="600"></canvas>
    </div>

<script>
/**
 * DOODLE JUMP CLONE
 */

// --- AUDIO MANAGER ---
// Uses Web Audio API to synthesize sounds (no external files needed!)
const sounds = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    play: function(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        switch (type) {
            case 'jump':
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(300, t + 0.1);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
                break;
            case 'shoot':
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
                break;
            case 'spring':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(600, t + 0.3);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.start(t);
                osc.stop(t + 0.3);
                break;
            case 'break':
                // Simple noise buffer for break/crumble
                this.playNoise(0.15);
                break;
            case 'monsterHit':
                // Noise + Low osc
                this.playNoise(0.1);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
                break;
            case 'boost': // Mike Throw
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.3);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.start(t);
                osc.stop(t + 0.3);
                break;
            case 'gameOver':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.5);
                osc.start(t);
                osc.stop(t + 0.5);
                break;
        }
    },
    playNoise: function(duration) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    // Loop handlers
    jetpackOsc: null,
    jetpackGain: null,
    startLoop: function(type) {
        if (!this.ctx || this.jetpackOsc) return;
        this.jetpackOsc = this.ctx.createOscillator();
        this.jetpackGain = this.ctx.createGain();
        
        if (type === 'jetpack') {
            this.jetpackOsc.type = 'sawtooth';
            this.jetpackOsc.frequency.value = 50;
        } else { // Propeller
            this.jetpackOsc.type = 'square';
            this.jetpackOsc.frequency.value = 15; // Low clicking
        }
        
        this.jetpackOsc.connect(this.jetpackGain);
        this.jetpackGain.connect(this.ctx.destination);
        this.jetpackGain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        this.jetpackOsc.start();
    },
    stopLoop: function() {
        if (this.jetpackOsc) {
            this.jetpackOsc.stop();
            this.jetpackOsc.disconnect();
            this.jetpackGain.disconnect();
            this.jetpackOsc = null;
            this.jetpackGain = null;
        }
    }
};

// --- Configuration ---
const CANVAS_WIDTH = 400;
const CANVAS_HEIGHT = 600;
const GRAVITY = 0.25;
const JUMP_FORCE = -8.5;
const SPRING_FORCE = -16;
const BOOST_FORCE = -30; 
const MOVE_SPEED = 6;
const PLATFORM_WIDTH = 60;
const PLATFORM_HEIGHT = 15;
const BULLET_SPEED = 10;

const TYPES = {
    NORMAL: 0,
    MOVING: 1,
    BREAKING: 2
};

const ITEMS = {
    NONE: 0,
    SPRING: 1,
    JETPACK: 2,
    SHIELD: 3,
    PROPELLER: 4
};

// --- Game Variables ---
let ctx, canvas;
let gameState = 0; // 0: Start, 1: Playing, 2: GameOver
let score = 0;
let highScore = localStorage.getItem('doodle_highscore_adv') || 0;
let totalCurrency = parseInt(localStorage.getItem('doodle_currency') || 0);
let lastTime = 0;

// Shop Data - Prices Increased x20
const CHARACTERS = [
    { id: 'classic', name: 'Classic', cost: 0 },
    { id: 'doge', name: 'Doge', cost: 20000 },
    { id: 'pepe', name: 'Pepe', cost: 50000 },
    { id: 'baseball', name: 'Tungtung', cost: 100000 }
];

const BACKGROUNDS = [
    { id: 'paper', name: 'Graph Paper', cost: 0 },
    { id: 'dark', name: 'Dark Mode', cost: 40000 },
    { id: 'matrix', name: 'Matrix', cost: 80000 }
];

let unlockedItems = JSON.parse(localStorage.getItem('doodle_unlocked') || '["classic", "paper"]');
let currentSkin = localStorage.getItem('doodle_skin') || 'classic';
let currentBg = localStorage.getItem('doodle_bg') || 'paper';

let player;
let platforms = [];
let enemies = [];
let bullets = [];
let mikeHits = 0;
let mikeRespawnTime = 0; // New variable for cooldown

// --- Input ---
const keys = { left: false, right: false };
let tiltX = 0; 

window.addEventListener('keydown', (e) => {
    if (gameState === 0 && e.key) sounds.init(); // Init sound on interaction

    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = true;
    
    if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'Enter') {
        if (gameState === 1) {
            shoot();
        } else if (gameState === 0) {
            if (!document.getElementById('start-screen').classList.contains('hidden')) startGame();
        } else if (gameState === 2) {
            startGame();
        }
    }
});

window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = false;
});

window.addEventListener('touchstart', (e) => {
    sounds.init(); // Init sound on touch
    if(e.target === canvas) e.preventDefault();
    if (gameState === 1) shoot();
}, {passive: false});

function handleOrientation(event) {
    let gamma = event.gamma; 
    if (gamma === null) return;
    if (gamma > 30) gamma = 30;
    if (gamma < -30) gamma = -30;
    tiltX = gamma / 30; 
}

function shoot() {
    if (!player) return;
    
    // Bat Mechanic: Can only throw if holding the bat
    if (currentSkin === 'baseball' && !player.hasBat) return;

    let spawnX = player.x + player.width / 2;
    if (player.facingRight) spawnX += 10;
    else spawnX -= 10;
    
    let type = (currentSkin === 'baseball') ? 'bat' : 'normal';
    bullets.push(new Bullet(spawnX, player.y, type));
    
    // Only play shoot sound if not bat (bat has whoosh implied)
    if (type !== 'bat') sounds.play('shoot');

    if (type === 'bat') {
        player.hasBat = false;
        sounds.play('jump'); // Small sound for throw
    }
}

// --- Graphics Helpers ---
function drawRocket(ctx, x, y, scale = 1, active = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    ctx.fillStyle = '#a0a0a0'; ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.rect(-10, -20, 20, 35); ctx.fill(); ctx.stroke();
    
    ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(-6, -18, 4, 30);

    ctx.fillStyle = '#fceabb'; ctx.beginPath(); ctx.moveTo(-10, -20); ctx.lineTo(10, -20); ctx.quadraticCurveTo(0, -35, 0, -35); ctx.lineTo(-10, -20); ctx.fill(); ctx.stroke();
    
    ctx.fillStyle = '#d3ad28'; ctx.beginPath(); ctx.moveTo(-5, -20); ctx.lineTo(5, -20); ctx.lineTo(0, -28); ctx.fill();

    ctx.fillStyle = '#666'; ctx.fillRect(-12, -10, 2, 15);
    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.moveTo(-8, 15); ctx.lineTo(8, 15); ctx.lineTo(10, 20); ctx.lineTo(-10, 20); ctx.fill();

    if (active) {
        ctx.fillStyle = (Math.floor(Date.now() / 50) % 2 === 0) ? '#ff4500' : '#ffa500';
        ctx.beginPath(); ctx.moveTo(-8, 20); ctx.lineTo(8, 20); ctx.lineTo(0, 20 + Math.random() * 25 + 10); ctx.fill();
        ctx.fillStyle = 'yellow';
        for(let i=0; i<3; i++) {
            let sx = (Math.random() - 0.5) * 10; let sy = 20 + Math.random() * 20;
            ctx.fillRect(sx, sy, 2, 2);
        }
    }
    ctx.restore();
}

// --- Classes ---

class Bullet {
    constructor(x, y, type = 'normal') {
        this.x = x; 
        this.y = y; 
        this.r = 4; 
        this.active = true;
        this.type = type;
        this.rotation = 0;
        this.vy = (type === 'bat') ? -15 : -BULLET_SPEED; // Initial upward velocity for bat
    }
    update() {
        if (this.type === 'bat') {
            this.vy += 0.5; // Gravity
            this.y += this.vy;
            this.rotation += 0.3;

            // Catch Logic: If bat is falling and near player
            if (this.vy > 0 && player) {
                let dist = Math.sqrt(Math.pow(this.x - (player.x + player.width/2), 2) + Math.pow(this.y - (player.y + player.height/2), 2));
                if (dist < 50) { // Catch radius
                    this.active = false;
                    player.hasBat = true;
                }
            }
            
            // Auto-return if lost off screen
            if (this.y > CANVAS_HEIGHT) {
                this.active = false;
                player.hasBat = true;
            }

        } else {
            this.y += this.vy;
            if (this.y < 0) this.active = false;
        }
    }
    draw() {
        if (!this.active) return;
        
        if (this.type === 'bat') {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // Draw Spinning Bat
            ctx.fillStyle = '#deb887'; 
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(0, 5); 
            ctx.lineTo(-2, -15); 
            ctx.lineTo(-4, -20); 
            ctx.quadraticCurveTo(0, -23, 4, -20); 
            ctx.lineTo(2, -15); 
            ctx.lineTo(0, 5); 
            ctx.fill(); 
            ctx.stroke();
            
            ctx.restore();
        } else {
            ctx.fillStyle = '#d3ad28'; 
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); 
            ctx.fill();
            ctx.lineWidth = 1; 
            ctx.strokeStyle = 'black'; 
            ctx.stroke();
        }
    }
}

class Doodler {
    constructor() {
        this.width = 40; this.height = 40;
        this.x = CANVAS_WIDTH / 2 - this.width / 2; this.y = CANVAS_HEIGHT - 150;
        this.vx = 0; this.vy = 0; this.facingRight = true;
        this.hasShield = false; 
        
        this.jetpackActive = false; this.jetpackTimer = 0;
        this.propellerActive = false; this.propellerTimer = 0; this.propellerAngle = 0;
        this.springBoostActive = false;
        this.mikeBoostActive = false; // New Flag for Mike Invincibility
        
        this.hasBat = true; // For Tungtung
    }
    update(dt) {
        if (keys.left) { this.vx = -MOVE_SPEED; this.facingRight = false; }
        else if (keys.right) { this.vx = MOVE_SPEED; this.facingRight = true; }
        else if (Math.abs(tiltX) > 0.1) {
            this.vx = tiltX * MOVE_SPEED;
            this.facingRight = (this.vx > 0);
        } else { this.vx = 0; }

        this.x += this.vx;
        if (this.x + this.width < 0) this.x = CANVAS_WIDTH;
        else if (this.x > CANVAS_WIDTH) this.x = -this.width;

        // Vertical Movement
        if (this.vy > 0) {
            // Falling - Reset Invincibility flags
            this.springBoostActive = false;
            this.mikeBoostActive = false;
        }

        if (this.jetpackActive) {
            this.vy = -12; this.jetpackTimer -= dt;
            if (this.jetpackTimer <= 0) { 
                this.jetpackActive = false; this.vy = -8; 
                sounds.stopLoop();
            }
        } else if (this.propellerActive) {
            this.vy = -8; 
            this.propellerTimer -= dt;
            this.propellerAngle += 0.8;
            if (this.propellerTimer <= 0) { 
                this.propellerActive = false; this.vy = -5; 
                sounds.stopLoop();
            }
        } else { 
            this.vy += GRAVITY; 
        }

        this.y += this.vy;
        if (this.y > CANVAS_HEIGHT) gameOver();
    }
    draw() {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        if (!this.facingRight) ctx.scale(-1, 1);

        if (this.jetpackActive) drawRocket(ctx, -20, 5, 0.8, true);

        ctx.strokeStyle = 'black'; ctx.lineWidth = 3; ctx.lineCap = 'round';
        let legOffset = (this.vy < 0 && !this.jetpackActive && !this.propellerActive) ? 5 : 0; 

        // --- Character Drawing Logic (Shared) ---
        if (currentSkin === 'classic') {
            // Legs
            ctx.beginPath(); ctx.moveTo(-10, 15); ctx.lineTo(-12, 25 - legOffset); ctx.lineTo(-16, 25 - legOffset); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(5, 15); ctx.lineTo(7, 25 + legOffset); ctx.lineTo(11, 25 + legOffset); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(10, 12); ctx.lineTo(15, 22); ctx.lineTo(19, 22); ctx.stroke();
            // Body
            ctx.fillStyle = '#e8e436';
            ctx.beginPath(); ctx.moveTo(-15, -15); ctx.quadraticCurveTo(-15, -25, 0, -25); ctx.quadraticCurveTo(15, -25, 15, -15);
            ctx.lineTo(15, -10); ctx.lineTo(30, -12); ctx.quadraticCurveTo(35, -5, 30, 2); 
            ctx.lineTo(15, 5); ctx.lineTo(16, 18); ctx.quadraticCurveTo(0, 22, -16, 18); ctx.lineTo(-15, -15); ctx.fill(); ctx.stroke();
            // Stripes
            ctx.strokeStyle = '#4a8034'; ctx.globalCompositeOperation = 'source-atop'; 
            ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(25, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-15, 8); ctx.lineTo(25, 8); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-16, 16); ctx.lineTo(18, 16); ctx.stroke();
            ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = 'black'; ctx.stroke();
            // Eyes
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.ellipse(-5, -12, 2, 4, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(5, -12, 2, 4, 0, 0, Math.PI*2); ctx.fill();
            // Snout
            if (this.facingRight) { ctx.beginPath(); ctx.ellipse(30, 2, 2, 5, 0.2, 0, Math.PI*2); ctx.fillStyle = 'black'; ctx.fill(); }

        } else if (currentSkin === 'doge') {
             // Legs
            ctx.beginPath(); ctx.moveTo(-10, 15); ctx.lineTo(-12, 25 - legOffset); ctx.lineTo(-16, 25 - legOffset); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(5, 15); ctx.lineTo(7, 25 + legOffset); ctx.lineTo(11, 25 + legOffset); ctx.stroke();
            // Doge Circle
            ctx.fillStyle = '#e6b86a';
            ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            // Ears
            ctx.beginPath(); ctx.moveTo(-15, -20); ctx.lineTo(-25, -35); ctx.lineTo(-5, -25); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(15, -20); ctx.lineTo(25, -35); ctx.lineTo(5, -25); ctx.fill(); ctx.stroke();
            // Eyes
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(-8, -5, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(8, -5, 3, 0, Math.PI*2); ctx.fill();
            // Snout
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(0, 10, 8, 6, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.ellipse(0, 8, 3, 2, 0, 0, Math.PI*2); ctx.fill();

        } else if (currentSkin === 'pepe') {
             // Legs
            ctx.beginPath(); ctx.moveTo(-10, 15); ctx.lineTo(-12, 25 - legOffset); ctx.lineTo(-16, 25 - legOffset); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(5, 15); ctx.lineTo(7, 25 + legOffset); ctx.lineTo(11, 25 + legOffset); ctx.stroke();
            // Frog Face
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath(); ctx.ellipse(0, -5, 25, 20, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            // Lips
            ctx.strokeStyle = '#D32F2F'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-15, 8); ctx.quadraticCurveTo(0, 15, 15, 8); ctx.stroke();
            // Eyes (Bulging)
            ctx.fillStyle = 'white'; ctx.strokeStyle = 'black';
            ctx.beginPath(); ctx.arc(-12, -15, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(12, -15, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(-12, -15, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(12, -15, 2, 0, Math.PI*2); ctx.fill();
            
        } else if (currentSkin === 'baseball') {
            // Tungtung Tung Sahur
            // Legs
            ctx.strokeStyle = '#b87333'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-8, 20); ctx.lineTo(-8, 35 - legOffset); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(8, 20); ctx.lineTo(8, 35 + legOffset); ctx.stroke();
            // Feet
            ctx.fillStyle = '#d2691e'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.ellipse(-12, 35 - legOffset, 8, 4, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(12, 35 + legOffset, 8, 4, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            // Body
            ctx.fillStyle = '#cd853f'; ctx.strokeStyle = '#8b4513'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-15, -40); ctx.quadraticCurveTo(0, -45, 15, -40); ctx.lineTo(15, 20);
            ctx.quadraticCurveTo(0, 25, -15, 20); ctx.closePath(); ctx.fill(); ctx.stroke();
            // Face
            ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.ellipse(-7, -25, 6, 8, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(7, -25, 6, 8, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(-7, -25, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(7, -25, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-3, -5); ctx.lineTo(3, -5); ctx.fill();
            ctx.strokeStyle = 'black'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(0, -2, 8, 0.2, Math.PI - 0.2, false); ctx.stroke();
            // Arms
            ctx.strokeStyle = '#b87333'; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(-15, -10); ctx.lineTo(-20, 10); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(22, 10); ctx.stroke();
            // Baseball Bat (CONDITIONAL)
            if (this.hasBat) {
                ctx.save(); ctx.translate(22, 10); ctx.rotate(-Math.PI / 3); 
                ctx.fillStyle = '#deb887'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(2, -30); ctx.lineTo(5, -35); 
                ctx.quadraticCurveTo(0, -38, -5, -35); ctx.lineTo(-2, -30); ctx.lineTo(0, 0); ctx.fill(); ctx.stroke();
                ctx.restore();
            }
        }

        // --- Propeller Cap Draw ---
        if (this.propellerActive) {
            ctx.save();
            // Adjust y position to sit on head based on skin
            let headY = -25;
            if (currentSkin === 'baseball') headY = -45;
            else if (currentSkin === 'doge' || currentSkin === 'pepe') headY = -30; // Larger heads
            
            ctx.translate(0, headY);
            
            // Beanie
            ctx.fillStyle = '#ff4081';
            ctx.beginPath(); ctx.arc(0, 0, 15, Math.PI, 0); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#3d5afe';
            ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); // Top stud
            
            // Spinning Blade
            ctx.translate(0, -5);
            ctx.rotate(this.propellerAngle);
            ctx.fillStyle = '#ffeb3b'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.ellipse(0, 0, 25, 4, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            
            ctx.restore();
        }

        if (this.jetpackActive) {
            ctx.strokeStyle = '#666'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-15, -5); ctx.lineTo(-5, -5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(-5, 10); ctx.stroke();
        }
        ctx.restore();

        if (this.hasShield) {
            ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)'; ctx.fillStyle = 'rgba(100, 200, 255, 0.2)';
            ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
        }
    }
}

class Platform {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.w = PLATFORM_WIDTH; this.h = PLATFORM_HEIGHT;
        this.type = type; this.dx = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random() * 2);
        this.breakState = 0; this.item = ITEMS.NONE;
        
        if (this.type !== TYPES.BREAKING && Math.random() < 0.12) {
            const r = Math.random();
            if (r < 0.6) this.item = ITEMS.SPRING;
            else if (r < 0.8) this.item = ITEMS.SHIELD;
            else if (r < 0.88) this.item = ITEMS.PROPELLER; // Rare (approx 8% of items)
            else this.item = ITEMS.JETPACK;
        }
        this.springAnim = 0; 
    }
    update() {
        if (this.type === TYPES.MOVING) {
            this.x += this.dx;
            if (this.x <= 0 || this.x + this.w >= CANVAS_WIDTH) this.dx *= -1;
        }
        if (this.breakState === 2) this.y += 4;
        if (this.springAnim > 0) this.springAnim--;
    }
    draw() {
        if (this.breakState === 2 && this.y > CANVAS_HEIGHT) return;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
        
        if (this.type === TYPES.BREAKING) { ctx.fillStyle = this.breakState === 1 ? '#5c2e0c' : '#8B4513'; } 
        else if (this.type === TYPES.MOVING) { ctx.fillStyle = '#6495ED'; } 
        else { ctx.fillStyle = '#6b8c42'; }
        
        this.drawRoundedRect(this.x, this.y, this.w, this.h, 6);

        if (this.type === TYPES.BREAKING && this.breakState >= 1) {
             ctx.beginPath(); ctx.moveTo(this.x + 10, this.y); ctx.lineTo(this.x + 20, this.y + 10); ctx.lineTo(this.x + 40, this.y + 2);
             ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.stroke();
        }
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.ellipse(this.x + this.w/2, this.y + 4, this.w/2 - 5, 2, 0, 0, Math.PI*2); ctx.fill();

        if (this.item === ITEMS.SPRING) this.drawSpring();
        if (this.item === ITEMS.JETPACK) drawRocket(ctx, this.x + this.w/2, this.y - 15, 0.6, false);
        if (this.item === ITEMS.SHIELD) this.drawShieldItem();
        if (this.item === ITEMS.PROPELLER) this.drawPropellerItem();
    }
    drawRoundedRect(x, y, w, h, r) {
        ctx.beginPath(); ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.fill(); ctx.stroke();
    }
    drawSpring() {
        let sx = this.x + this.w/2; let sy = this.y; let h = (this.springAnim > 0) ? 25 : 10;
        ctx.strokeStyle = '#888'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(sx - 5, sy); ctx.lineTo(sx - 5, sy - h); ctx.lineTo(sx + 5, sy - h); ctx.lineTo(sx + 5, sy); ctx.stroke();
        ctx.lineWidth = 1; ctx.beginPath();
        let segments = (this.springAnim > 0) ? 6 : 3; let segHeight = h / segments;
        ctx.moveTo(sx-5, sy);
        for(let i=0; i<segments; i++) {
            let y1 = sy - (i * segHeight); let y2 = sy - ((i+1) * segHeight);
            ctx.lineTo(sx+5, y1 - segHeight/2); ctx.lineTo(sx-5, y2);
        }
        ctx.stroke();
    }
    drawShieldItem() {
        let cx = this.x + this.w/2; let cy = this.y - 12;
        ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI*2); ctx.fillStyle = 'rgba(100, 200, 255, 0.8)'; ctx.fill();
        ctx.strokeStyle = 'blue'; ctx.stroke(); ctx.fillStyle = 'white'; ctx.font = '10px Arial'; ctx.fillText('S', cx-3, cy+3);
    }
    drawPropellerItem() {
        let cx = this.x + this.w/2; let cy = this.y - 5;
        ctx.fillStyle = '#ff4081'; ctx.beginPath(); ctx.arc(cx, cy, 10, Math.PI, 0); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#3d5afe'; ctx.beginPath(); ctx.arc(cx, cy-10, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#ffeb3b'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.ellipse(cx, cy-14, 16, 3, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    }
}

class Enemy {
    constructor(x, y) {
        this.x = x; this.y = y; this.width = 40; this.height = 30; this.dx = 2; this.active = true;
    }
    update() {
        this.x += this.dx;
        if (this.x <= 0 || this.x + this.width >= CANVAS_WIDTH) this.dx *= -1;
    }
    draw() {
        if (!this.active) return;
        let cx = this.x + this.width/2; let cy = this.y + this.height/2;
        ctx.fillStyle = '#a335ee'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.bezierCurveTo(cx-20, cy-20, cx+20, cy-20, cx+20, cy); ctx.bezierCurveTo(cx+20, cy+20, cx-20, cy+20, cx-20, cy); ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(cx - 8, cy - 5, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(cx + 8, cy - 5, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(cx - 8 + this.dx, cy - 5, 2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx + 8 + this.dx, cy - 5, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(cx - 10, cy + 8); ctx.lineTo(cx + 10, cy + 8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx - 20, cy - 5); ctx.lineTo(cx - 30, cy - 15); ctx.moveTo(cx + 20, cy - 5); ctx.lineTo(cx + 30, cy - 15); ctx.strokeStyle = '#a335ee'; ctx.lineWidth = 4; ctx.stroke();
    }
    hit() {
        this.active = false;
        sounds.play('monsterHit');
    }
}

class FlyingMonster {
    constructor(x, y) {
        this.x = x; this.y = y; this.width = 40; this.height = 30; this.dx = 2; this.active = true;
    }
    update() {
        this.x += this.dx;
        if (this.x <= 0 || this.x + this.width >= CANVAS_WIDTH) this.dx *= -1;
    }
    draw() {
        if (!this.active) return;
        let cx = this.x + this.width/2; let cy = this.y + this.height/2;
        ctx.fillStyle = '#4da6ff'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(cx - 15, cy - 5); ctx.quadraticCurveTo(cx - 30, cy - 20, cx - 35, cy - 5); ctx.quadraticCurveTo(cx - 30, cy + 10, cx - 15, cy + 5);
        ctx.moveTo(cx + 15, cy - 5); ctx.quadraticCurveTo(cx + 30, cy - 20, cx + 35, cy - 5); ctx.quadraticCurveTo(cx + 30, cy + 10, cx + 15, cy + 5);
        ctx.fillStyle = '#3d8ccc'; ctx.fill(); ctx.stroke();

        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(cx - 6, cy - 3, 5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(cx + 6, cy - 3, 5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(cx - 6, cy - 3, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 6, cy - 3, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx, cy + 8, 3, 0, Math.PI*2); ctx.fillStyle = 'black'; ctx.fill();
    }
    hit() {
        this.active = false;
        sounds.play('monsterHit');
    }
}

class GreenMonster {
    constructor(platform) {
        this.platform = platform;
        this.w = 50;
        this.h = 50;
        this.baseY = platform.y - this.h; 
        this.x = platform.x + platform.w / 2 - this.w / 2;
        this.y = this.baseY;
        this.active = true;
        this.state = 'IDLE'; 
        this.vy = 0; 
        this.idleTimer = 0;
        this.isJumping = false;
        this.jumpY = 0;
        this.boostTimer = 0;
        this.pose = 'STAND';
    }

    update() {
        if (!this.active) return;
        if (this.platform.y > CANVAS_HEIGHT) { this.active = false; return; }

        if (this.state === 'IDLE') {
            this.idleTimer++;
            if (!this.isJumping) {
                this.pose = 'STAND';
                if (this.idleTimer > 120) { this.isJumping = true; this.idleTimer = 0; }
            } else {
                this.idleTimer++;
                let progress = this.idleTimer / 40; 
                if (progress > 1) {
                    this.isJumping = false; this.jumpY = 0; this.idleTimer = 0;
                } else {
                    this.jumpY = -Math.sin(progress * Math.PI) * 15; this.pose = 'JUMP';
                }
            }
            this.baseY = this.platform.y - this.h + 5; 
            this.y = this.baseY + this.jumpY;

        } else if (this.state === 'BOOSTING') {
            this.boostTimer--;
            if (this.boostTimer > 15) { this.jumpY = 10; this.pose = 'SQUAT'; } else { this.jumpY = -10; this.pose = 'THROW'; }
            this.baseY = this.platform.y - this.h + 5;
            this.y = this.baseY + this.jumpY;
            if (this.boostTimer <= 0) { this.state = 'IDLE'; this.isJumping = false; this.jumpY = 0; }
        } else if (this.state === 'FLEEING') {
            this.vy -= 0.5; this.y += this.vy;
            if (this.y < -100) this.active = false;
        } else if (this.state === 'DYING') {
            this.vy += GRAVITY; this.y += this.vy;
            // When Mike falls off screen, start cooldown
            if (this.y > CANVAS_HEIGHT) {
                this.active = false;
                mikeRespawnTime = performance.now() + 20000; // 20 seconds from now
            }
        }
        this.x = this.platform.x + this.platform.w / 2 - this.w / 2;
    }
    
    hit() {
        if (this.state === 'BOOSTING') return;
        mikeHits++;
        sounds.play('monsterHit');
        if (mikeHits < 3) { this.state = 'FLEEING'; this.vy = -15; } else { this.state = 'DYING'; this.vy = 5; }
    }
    
    triggerBoost(player) {
        if (this.state !== 'IDLE') return;
        this.state = 'BOOSTING';
        this.boostTimer = 30; 
        player.vy = BOOST_FORCE; 
        player.y = this.y - player.height;
        // Fix: Make player invincible while flying up
        player.mikeBoostActive = true;
        sounds.play('boost');
    }

    draw() {
        if (!this.active) return;
        let cx = this.x + this.w/2; let cy = this.y + this.h/2;
        let scaleY = 1; let rotation = 0;
        if (this.state === 'FLEEING') this.pose = 'THROW'; 
        else if (this.state === 'DYING') { scaleY = 1.1; rotation = 0.1; }
        else if (this.pose === 'THROW') scaleY = 0.9;
        else if (this.pose === 'SQUAT') scaleY = 1.2;
        else if (this.pose === 'JUMP') scaleY = 0.95;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);
        ctx.scale(1, scaleY);
        // Body
        ctx.fillStyle = '#8bc34a'; ctx.strokeStyle = '#33691e'; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        // Eyes
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(-7, -8, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke(); 
        ctx.beginPath(); ctx.arc(7, -8, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke(); 
        // Pupils
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(-7, -8, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(7, -8, 1.5, 0, Math.PI*2); ctx.fill();
        // Nose
        ctx.fillStyle = '#558b2f'; ctx.beginPath(); ctx.ellipse(0, 0, 3, 2, 0, 0, Math.PI*2); ctx.fill();
        // Mouth
        ctx.strokeStyle = '#33691e'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-5, 8); ctx.lineTo(5, 8); ctx.stroke();
        // Horns
        ctx.fillStyle = '#e0e0e0'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-10, -15); ctx.lineTo(-15, -25); ctx.lineTo(-5, -18); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10, -15); ctx.lineTo(15, -25); ctx.lineTo(5, -18); ctx.closePath(); ctx.fill(); ctx.stroke();
        // Arms/Hands
        ctx.strokeStyle = '#33691e'; ctx.lineWidth = 3;
        let armY = 15, handY = 25;
        if (this.state === 'BOOSTING' || this.state === 'FLEEING') { armY = -20; handY = -30; }
        ctx.beginPath(); ctx.moveTo(-18, 0); ctx.lineTo(-25, armY); ctx.stroke();
        ctx.beginPath(); ctx.arc(-25, handY, 3, 0, Math.PI*2); ctx.fillStyle='#8bc34a'; ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(18, 0); ctx.lineTo(25, armY); ctx.stroke();
        ctx.beginPath(); ctx.arc(25, handY, 3, 0, Math.PI*2); ctx.fillStyle='#8bc34a'; ctx.fill(); ctx.stroke();
        // Legs
        ctx.strokeStyle = '#33691e'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(-5, 18); ctx.lineTo(-8, 30); ctx.lineTo(-12, 30); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(5, 18); ctx.lineTo(8, 30); ctx.lineTo(12, 30); ctx.stroke();
        ctx.restore();
    }
}

// --- Main Logic ---

function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    document.getElementById('start-btn').onclick = () => { sounds.init(); startGame(); };
    document.getElementById('restart-btn').onclick = () => { sounds.init(); startGame(); };
    document.getElementById('shop-btn').onclick = openShop;
    document.getElementById('shop-btn-over').onclick = openShop;
    document.getElementById('close-shop-btn').onclick = closeShop;

    document.getElementById('highscore-display').innerText = "Top: " + highScore;

    renderShop();
    requestAnimationFrame(loop);
}

function startGame() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().catch(console.error);
        window.addEventListener('deviceorientation', handleOrientation);
    } else {
        window.addEventListener('deviceorientation', handleOrientation);
    }

    gameState = 1; 
    score = 0;
    mikeHits = 0;
    mikeRespawnTime = 0; // Reset cooldown on new game
    document.getElementById('score-display').innerText = score;
    document.getElementById('highscore-display').innerText = "Top: " + highScore; 
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('shop-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');

    player = new Doodler();
    platforms = [];
    enemies = [];
    bullets = [];
    
    // Start Platform
    let startPlat = new Platform(CANVAS_WIDTH/2 - PLATFORM_WIDTH/2, CANVAS_HEIGHT - 60, TYPES.NORMAL);
    startPlat.item = ITEMS.NONE;
    platforms.push(startPlat);

    // Initial Platforms
    for (let i = 1; i < 7; i++) {
        let y = CANVAS_HEIGHT - 80 - i * 90;
        let x = Math.random() * (CANVAS_WIDTH - PLATFORM_WIDTH);
        platforms.push(new Platform(x, y, TYPES.NORMAL));
    }
    
    lastTime = performance.now();
}

function loop(timestamp) {
    let dt = (timestamp - lastTime) / 16;
    lastTime = timestamp;

    if (gameState === 1) {
        update(dt);
        render();
    } else if (gameState === 0) {
        render();
    }

    requestAnimationFrame(loop);
}

function update(dt) {
    player.update(dt);

    // Check Mike Cooldown
    if (mikeHits >= 3 && mikeRespawnTime > 0 && performance.now() > mikeRespawnTime) {
        mikeHits = 0;
        mikeRespawnTime = 0;
        // Mike can now spawn again in generateWorld
    }
    
    bullets.forEach((b) => {
        b.update();
        if (!b.active) return;
        
        enemies.forEach((e) => {
            if (!e.active) return;
            let hit = false;
            if (e instanceof GreenMonster) {
                let dx = b.x - (e.x + e.w/2);
                let dy = b.y - (e.y + e.h/2);
                if (Math.sqrt(dx*dx + dy*dy) < 30) hit = true;
            } else {
                if (b.x > e.x && b.x < e.x + e.width && b.y > e.y && b.y < e.y + e.height) hit = true;
            }

            if (hit) {
                if (e instanceof GreenMonster) {
                    if (e.state === 'IDLE' || e.state === 'BOOSTING') { e.hit(); b.active = false; score += 50; }
                } else {
                    e.hit(); b.active = false; score += 50; 
                }
            }
        });
    });
    bullets = bullets.filter(b => b.active);

    if (player.vy > 0 && !player.jetpackActive && !player.propellerActive) {
        platforms.forEach(p => {
            if (player.x < p.x + p.w && player.x + player.width > p.x &&
                player.y + player.height > p.y && player.y + player.height < p.y + p.h + player.vy + 5) 
            {
                let wasSpring = (p.item === ITEMS.SPRING);
                if (p.item !== ITEMS.NONE) {
                    applyItem(p.item);
                    if (p.item !== ITEMS.SPRING) p.item = ITEMS.NONE;
                    else {
                        p.springAnim = 15;
                        sounds.play('spring');
                    }
                }
                
                if (wasSpring) {
                    player.vy = SPRING_FORCE;
                    player.springBoostActive = true; // Immune start
                } else if (p.type === TYPES.BREAKING) {
                    if (p.breakState === 0) { p.breakState = 1; player.vy = JUMP_FORCE; sounds.play('break'); }
                    else if (p.breakState === 1) { p.breakState = 2; player.vy = JUMP_FORCE; sounds.play('break'); }
                } else {
                    player.vy = JUMP_FORCE;
                    sounds.play('jump');
                }
            }
        });
    }

    enemies.forEach(e => {
        if (!e.active) return;
        
        if (e instanceof GreenMonster) {
            let cx = e.x + e.w/2; let cy = e.y + e.h/2;
            if (player.x < cx + 20 && player.x + player.width > cx - 20 &&
                player.y < cy + 20 && player.y + player.height > cy - 20) 
            {
                 // Fix: Added mikeBoostActive to immunity check
                 if (player.jetpackActive || player.propellerActive || player.springBoostActive || player.mikeBoostActive) return; // Immune!

                 if (player.vy > 0 && player.y + player.height - player.vy < cy - 5) {
                      if (e.state === 'IDLE') { e.triggerBoost(player); score += 200; }
                      else { if (player.hasShield) { player.hasShield = false; player.vy = -5; } else gameOver(); }
                 } else {
                     if (player.hasShield) { player.hasShield = false; player.vy = -5; } else gameOver();
                 }
            }
            return;
        }

        if (player.x < e.x + e.width && player.x + player.width > e.x &&
            player.y < e.y + e.height && player.y + player.height > e.y) 
        {
            if (player.jetpackActive || player.propellerActive || player.springBoostActive || player.mikeBoostActive) return; // Immune!

            if (player.vy > 0 && player.y + player.height - player.vy < e.y + e.height / 2) {
                e.active = false; player.vy = JUMP_FORCE * 1.5; score += 100;
                sounds.play('monsterHit');
            } else {
                if (player.hasShield) { player.hasShield = false; e.active = false; player.vy = -5; }
                else gameOver();
            }
        }
    });

    platforms.forEach(p => p.update());
    enemies.forEach(e => e.update());

    let threshold = CANVAS_HEIGHT * 0.45;
    if (player.y < threshold) {
        let diff = threshold - player.y;
        player.y = threshold;
        
        platforms.forEach(p => p.y += diff);
        enemies.forEach(e => { e.y += diff; });
        bullets.forEach(b => b.y += diff); 
        
        score += Math.floor(diff);
        document.getElementById('score-display').innerText = score;
        
        platforms = platforms.filter(p => p.y < CANVAS_HEIGHT);
        enemies = enemies.filter(e => e.active); 
        
        generateWorld();
    }
}

function applyItem(type) {
    if (type === ITEMS.JETPACK) { 
        player.jetpackActive = true; player.jetpackTimer = 180; 
        sounds.startLoop('jetpack');
    }
    else if (type === ITEMS.PROPELLER) { 
        player.propellerActive = true; player.propellerTimer = 220; 
        sounds.startLoop('propeller');
    }
    else if (type === ITEMS.SHIELD) { player.hasShield = true; }
}

function generateWorld() {
    if (platforms.length < 7) {
        let minY = CANVAS_HEIGHT;
        platforms.forEach(p => minY = Math.min(minY, p.y));
        
        let y = minY - (60 + Math.random() * 60);
        let x = Math.random() * (CANVAS_WIDTH - PLATFORM_WIDTH);
        
        let type = TYPES.NORMAL;
        if (score > 500 && Math.random() < 0.2) type = TYPES.MOVING;
        if (score > 1000 && Math.random() < 0.2) type = TYPES.BREAKING;
        if (score > 2500 && Math.random() < 0.3) type = TYPES.BREAKING;

        let p = new Platform(x, y, type);
        platforms.push(p);

        let activeGreen = enemies.some(e => e instanceof GreenMonster && e.active);
        if (!activeGreen && mikeHits < 3 && Math.random() < 0.05 && score > 200 && p.type !== TYPES.BREAKING) {
            enemies.push(new GreenMonster(p));
        }
    }

    if (score > 500 && enemies.length < 2 && Math.random() < 0.02) {
        let y = -100; 
        let x = Math.random() * (CANVAS_WIDTH - 40);
        if (Math.random() > 0.5) enemies.push(new Enemy(x, y));
        else enemies.push(new FlyingMonster(x, y));
    }
}

function gameOver() {
    gameState = 2;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('doodle_highscore_adv', highScore);
    }
    sounds.stopLoop();
    sounds.play('gameOver');
    
    // Update Total Currency
    totalCurrency += score;
    localStorage.setItem('doodle_currency', totalCurrency);
    document.getElementById('total-coins-display').innerText = totalCurrency;

    document.getElementById('final-score').innerText = score;
    document.getElementById('final-high').innerText = highScore;
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
}

function render() {
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Background Logic
    if (currentBg === 'dark') {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.strokeStyle = '#333'; 
    } else if (currentBg === 'matrix') {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.fillStyle = '#0f0';
        ctx.font = '10px monospace';
        for(let i=0; i<10; i++) ctx.fillText(Math.random() > 0.5 ? '1' : '0', Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT);
        ctx.strokeStyle = '#003300';
    } else {
        // Default Paper
        ctx.strokeStyle = '#e0d8c3'; 
    }

    if (currentBg !== 'matrix' && currentBg !== 'dark') {
        ctx.lineWidth = 1; ctx.beginPath();
        for (let x = 0; x <= CANVAS_WIDTH; x += 20) { ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); }
        for (let y = 0; y <= CANVAS_HEIGHT; y += 20) { ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); }
        ctx.stroke();
    }

    platforms.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    bullets.forEach(b => b.draw());
    
    if (gameState === 1) player.draw();
}

// --- Shop Logic ---
function openShop() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('shop-screen').classList.remove('hidden');
    renderShop();
}

function closeShop() {
    document.getElementById('shop-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
}

function renderShop() {
    document.getElementById('shop-currency').innerText = totalCurrency;
    
    // Characters
    const charGrid = document.getElementById('char-grid');
    charGrid.innerHTML = '';
    CHARACTERS.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item ' + (currentSkin === item.id ? 'selected' : '');
        if (!unlockedItems.includes(item.id)) div.className += ' locked';
        
        div.innerHTML = `
            <div class="item-name">${item.name}</div>
            <div class="item-cost">${unlockedItems.includes(item.id) ? 'Owned' : item.cost + ' Coins'}</div>
        `;
        div.onclick = () => buyOrEquip('skin', item);
        charGrid.appendChild(div);
    });

    // Backgrounds
    const bgGrid = document.getElementById('bg-grid');
    bgGrid.innerHTML = '';
    BACKGROUNDS.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item ' + (currentBg === item.id ? 'selected' : '');
        if (!unlockedItems.includes(item.id)) div.className += ' locked';
        
        div.innerHTML = `
            <div class="item-name">${item.name}</div>
            <div class="item-cost">${unlockedItems.includes(item.id) ? 'Owned' : item.cost + ' Coins'}</div>
        `;
        div.onclick = () => buyOrEquip('bg', item);
        bgGrid.appendChild(div);
    });
}

function buyOrEquip(type, item) {
    if (unlockedItems.includes(item.id)) {
        // Equip
        if (type === 'skin') currentSkin = item.id;
        if (type === 'bg') currentBg = item.id;
        localStorage.setItem('doodle_skin', currentSkin);
        localStorage.setItem('doodle_bg', currentBg);
        renderShop();
    } else {
        // Buy
        if (totalCurrency >= item.cost) {
            totalCurrency -= item.cost;
            unlockedItems.push(item.id);
            localStorage.setItem('doodle_currency', totalCurrency);
            localStorage.setItem('doodle_unlocked', JSON.stringify(unlockedItems));
            
            // Auto equip
            if (type === 'skin') currentSkin = item.id;
            if (type === 'bg') currentBg = item.id;
            localStorage.setItem('doodle_skin', currentSkin);
            localStorage.setItem('doodle_bg', currentBg);
            
            renderShop();
        } else {
            alert("Not enough coins!");
        }
    }
}

init();

</script>
</body>
</html>